---
description: 
globs: 
alwaysApply: true
---
## 1. プロジェクトの目的 (Project Purpose)
このプロジェクトは競馬のデータベースから取得したデータを機械学習を用いて分析し、的中率および回収率の高い馬券戦略を導くことを目的としています。
主な機能は、データ取得、特徴量データ作成、学習データと検証データへの分割、機械学習、検証と結果の表示・出力、新規データでの予測と予測結果の表示・出力です。
利用者はプロジェクト作成者のみです。

## 2. 環境等の前提条件 (Development Environment)
* **プログラミング言語:** Python
* **データベース:** PostgreSQL 17
* **ORM:** SQLAlchemy 
* **OS:** Windows 11
* **Library:** keras
* **その他:** Git, Github

## 3. 機能仕様 (Functional Specifications)

### 3.1. データ取得(Must-have condition)
* データベースからデータを取得する
* データベースへの接続はdb/connector.pyを使用する
* データを取得するSQL
    * **レース情報:** db/get_race_data.sql
    * **馬ごとレース情報:** db/get_umagoto_race.sql
    * **前走ID情報:** db/get_zensou_id.sql
* 各データの説明
    * **レース情報**
        * **race_id:** レースを一意に識別するID。開催年月日(YYYYMMDD)+競馬場コード(NN)+レース番号(NN)で構成される。
        * **keibajo_code:** 競馬場コード。01～10がJRAの競馬場、それ以外の値は海外、地方競馬の競馬場コードを表す。
        * **track_code:** コースのトラックコード。2桁の数値で表される。01～29までを分析の対象とする。
        * **kyori:** コースの距離。整数型。
        * **babacd:** 馬場状態コード。1:量馬場、2:やや重、3:重、4:不良。
        * **tosu:** 出走頭数。整数型、最大18頭。
        * **grade_code:** 重賞コード。1～5で、1が最もグレードが高い重賞、5はグレードなし。
        * **mu:** レースレーティング。数値型で値が大きいほどレースのレベルが高い。
    * **馬ごとレース情報**
        * **race_id:** レースを一意に識別するID。レース情報と紐づけに使用する。
        * **ketto_toroku_bango:** 馬の血統登録番号。前走ID情報との紐づけに使用する。
        * **horse_id:** 馬を一意に識別するID。馬名(カタカナ)を使用している。
        * **umaban:** レースでの馬番号。1～18の整数値。
        * **ketto1_bamei:** その馬の父(種牡馬)の馬名。
        * **kisyu_id:** その馬に当該レースで騎乗した騎手の名前。
        * **odds:** 単勝オッズ。1.0～999.9の値をとる。賭け金1に対してその馬が勝てばオッズの値が報酬として得られる。
        * **ninki:** 人気順。1～18の整数値。値が小さいほど、そのレースでの人気が高いことを表す。
        * **bataiju:** 馬体重。3桁の整数値。
        * **batai_zogen:** 馬体重の前走からの増減値。整数で表され、前走の情報がない場合は0。
        * **futan:** 負担重量。数値型、馬が背負う重量で重いほど不利となる。
        * **sire_rate:** その馬の種牡馬の産駒の連帯率。
        * **sire_joken_rate:** その馬の種牡馬の産駒がそのレースと同一条件（競馬場、トラックコード、距離）で走った時の連帯率。
        * **jockey_rate:** 騎乗した騎手の連帯率。
        * **hensa:** その馬のレーティングをレースの出走馬内で偏差値をとった値。高いほど連帯率が上がる傾向があり、偏差値(x)と連帯率(y)の統計をとると、正の指数関数で近似され、決定係数0.99以上の高い相関を示す。
        * **rate_diff:** その馬の前走のレースレーティングと今回のレースレーティングの差。正の場合は今回のレースレーティングが高い(レースのレベルが前回よりも高い)ことを示す。
        * **race_order:** レースの順位。1～18の整数値。
        * **soha_time:** レースの走破タイム。0.1秒単位の整数値。例:648の場合は、64.8秒のタイムでゴールしたことを示す。
        * **kohan_3f:** レースのゴール前3ハロン(600メートル)のタイム。0.1秒単位の整数値。例:341の場合は34.1秒で最終600メートルを走ったことを示す。
        * **corner1:** 1コーナーの通過順位。1～18の整数値。
        * **corner2:** 2コーナーの通過順位。1～18の整数値。
        * **corner3:** 3コーナーの通過順位。1～18の整数値。
        * **corner4:** 4コーナーの通過順位。1～18の整数値。
    * **前走ID情報**
        * **ketto_toroku_bango:** 馬の血統登録番号。馬ごとレース情報との紐づけに使用する。
        * **race_id:** レースを一意に識別するID。レース情報、馬ごとレース情報と紐づけに使用する。
        * **pre1_race_id:** 前走のレースID。レース情報、馬ごとレース情報と紐づけて、前走の情報を構成する。
        * **pre2_race_id:** 2走前のレースID。レース情報、馬ごとレース情報と紐づけて、2走前の情報を構成する。
        * **pre3_race_id:** 3走前のレースID。レース情報、馬ごとレース情報と紐づけて、3走前の情報を構成する。
        * **pre4_race_id:** 4走前のレースID。レース情報、馬ごとレース情報と紐づけて、4走前の情報を構成する。
        * **pre5_race_id:** 5走前のレースID。レース情報、馬ごとレース情報と紐づけて、5走前の情報を構成する。

### 3.2. 特徴量データ作成(Must-have condition)
* race_id単位で以下の構造の特徴量データを作成する。([レース情報,[馬ごとレース情報,[前走以前のレース情報、馬ごとレース情報]]])
[race_id,keibajo_code,track_code,kyori,babacd,tosu,grade_code,mu
,[horse_id,umaban,ketto1_bamei,kisyu_id,odds,ninki,bataiju,batai_zogen,futan,sire_rate,sire_joken_rate,jockey_rate,hensa,rate_diff,[pre1_race_id,レース情報,馬ごとレース情報],・・・（前走～最大5走前までの繰り返し）
],・・・（1頭目から最大18頭目までの繰り返し）
]
* データの長さ、数は最大数に合わせて固定する。
* 欠損データをデータ型に合わせて0などで補完する。
* レース情報はrace_idのkaisai_nen(YYYY)が2018～2024のデータを対象とする。
* 前走～5走前のレース情報はkaisai_nenが2017～2024のデータを対象とする。

### 3.3. 学習データと検証データへの分割(Must-have condition)
* 作成した特徴量データをrace_id単位でランダムに80％を学習データ、20%を検証データとなるように分割する。

### 3.4. 機械学習(Must-have condition)
* 学習データを用いてTransformerによる機械学習を行う。
* 学習する目的変数はrace_orderとし、各出走馬が1着になる確率を計算する。実際に1着の馬が確率が高くなるように学習する。
* race_idは大きいものが最新のデータとなる時系列データであるため、Positional Encordingで時系列を反映させる。
* 学習したモデルを保存する。

### 3.5. 検証と結果の表示・出力(Must-have condition)
* 保存したモデルを使用して、検証データで各馬の勝率を予測し、予測勝率と実際の着順の一致率を表示する。
* レース、出走馬ごとのrace_id,horse_id,予測勝率,実際の着順,oddsをCSVファイルに出力する。
* 予測勝率と実際の着順の相関を計算し、結果を出力する。
* 予測勝率のレース内での順位と実際の着順の相関を計算し、結果を出力する。

### 3.6. 新規データでの予測と予測結果の表示・出力(Later)

## 4. データベーススキーマ (Database Schema)
* db/schema.sql のテーブル定義、マテリアルビュー定義を参照

## 5. テスト戦略 (Testing Strategy)
* **単体テスト:**
    * 全ての関数およびメソッドに対して pytest を用いた単体テストを記述する。
    * モック（unittest.mock）を積極的に使用し、外部依存を排除する。
    * カバレッジ目標: C0/C1カバレッジ100％
* **テストフレームワーク:** pytest

## 6. コーディング規約 (Coding Conventions)
* Python コードは PEP 8 に準拠する。
* 変数名、関数名は snake_case、クラス名は PascalCase とする。
* Docstring は Sphinx 形式で記述し、引数と戻り値を明記する。
* 型ヒントを積極的に使用する。
* ロギングは Python の `logging` モジュールを使用し、ログレベルを適切に設定する。

## 7. アーキテクチャの指針 (Architectural Guidelines)
* クリーンアーキテクチャ（またはレイヤードアーキテクチャ）を基本とする。
* ドメイン層はフレームワークに依存しないように設計する。
* 依存性の注入 (Dependency Injection) を利用する。
* 各サービスは単一責任の原則に従う。

## 8. プロジェクト構造 (structure)
* ソースコードはsrcフォルダに作成する。ただし、DB作成用のconnector.pyのみdbフォルダに格納する。
* SQLファイルはdbフォルダに作成する。
* CSVなど出力データファイルはdataフォルダに作成する。
* 機械学習モデルはmodelフォルダに保存する。
* 指示したプロンプトと回答内容はすべてprompt/prompt.txtに記録する。
* ログはlogsフォルダ下に作成する。
* 以下のファイルは絶対に書き換えないでください。既にあるものを参照するようにしてください。
    * db/connector.py
    * db/get_race_data.sql
    * db/get_umagoto_race.sql
    * db/get_zensou_id.sql
    * db/schema.sql

